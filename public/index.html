<!DOCTYPE html>
<html lang="">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <link rel="icon" href="<%= BASE_URL %>favicon.ico">
  <title>
    <%= htmlWebpackPlugin.options.title %>
  </title>
</head>

<body>
  <noscript>
    <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled.
        Please enable it to continue.</strong>
  </noscript>
  <div id="app"></div>
  <!-- <svg width="960" height="600"></svg> -->
  <!-- built files will be auto injected -->
  <!-- <script src="https://d3js.org/d3.v4.min.js"></script>
  <script>
    var svg = d3.select("svg"), g,
      width = +svg.attr("width"),
      height = +svg.attr("height"),
      node, link,
      brushMode, brush, zoomLayer; //intercation canvas: Brush + zoom

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    // var simulation = d3.forceSimulation()
    //   .force("link", d3.forceLink().id(function (d) { return d.id; }))
    //   .force("charge", d3.forceManyBody())ƒ
    //   .force("center", d3.forceCenter(width / 2, height / 2));

    var simulation = d3.forceSimulation()
      .force("link", d3.forceLink().id(function (d) {
        return d.id;
      }))
      .force("charge", d3.forceManyBody().strength(-200).distanceMax(200)) // strength 默认 -30
      .force("center", d3.forceCenter(width / 2, height / 2));


    // add shift event
    d3.select("body")
      .on("keydown", keydown)
      .on("keyup", keyup)

    // brushable network: http://jsfiddle.net/pkerpedjiev/29majy5c/2/
    brush = d3.brush()
      .extent([[0, 0], [width, height]])
      .on("start", function () {
        node.each(function (d) { d.previouslyPicked = brushMode && d.picked; });
      })
      .on("brush", function () {
        if (!d3.event.selection) return;
        var extent = d3.event.selection,
          zoomProp = d3.zoomTransform(zoomLayer.node());
        node.classed("picked", function (d) { return d.picked = d.previouslyPicked ^ ((extent[0][0] - zoomProp.x) / zoomProp.k <= d.x && d.x < (extent[1][0] - zoomProp.x) / zoomProp.k && (extent[0][1] - zoomProp.y) / zoomProp.k <= d.y && d.y < (extent[1][1] - zoomProp.y) / zoomProp.k); });
      })
      .on("end", function () {
        if (!d3.event.selection) return;
        d3.select(this).call(d3.event.target.move, null);
      })

    let zoom = d3.zoom()
      .scaleExtent([1 / 2, 4])
      .on("zoom", zoomed);

    svg.append("g")
      .attr("id", "brush-layer")
      .attr("width", width)
      .attr("height", height)
      .style("fill", "none")
      .datum(function () { return { picked: false, previouslyPicked: false }; })
      .call(brush)
      .on("click", function () {
        node.classed("picked", false);
        node.each(function (d) { d.picked = d.previouslyPicked = false; })
      });


    zoomLayer = svg.append("rect")
      .attr("id", "zoom-layer")
      .attr("width", width)
      .attr("height", height)
      .style("fill", "none")
      .attr("pointer-events", "all")
      .call(zoom)

    g = svg.append("g");

    d3.json("drawgraph_test.json", function (error, graph) {
      if (error) throw error;
      graph.nodes = graph.st.map(item => {
        return {
          id: item.mRID,
          group: Math.floor(Math.random() * 5 + 1)
        }
      })
      graph.links = graph.line.map(item => {
        return {
          source: item.StartSt,
          target: item.EndSt,
          value: 2
        }
      })
      link = g.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(graph.links)
        .enter().append("line")
        .attr("stroke-width", function (d) { return Math.sqrt(d.value); });

      node = g.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(graph.nodes)
        .enter().append("circle")
        .attr("r", 20)
        .attr("fill", function (d) { return color(d.group); })
        .on("click", function () {
          var thisNode = d3.select(this);
          if (brushMode) {
            node.each(function (d) { d.previouslyPicked = brushMode && d.picked; });
            node.classed("picked", function (d) {
              return d.picked = d.previouslyPicked ^ (thisNode.datum().id === d.id);
            });
          }
        })
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged));
      // .on("end", dragended));


      node.append("title")
        .text(function (d) { return d.id; });


      simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

      simulation.force("link")
        .links(graph.links);

      function ticked() {
        link
          .attr("x1", function (d) { return d.source.x; })
          .attr("y1", function (d) { return d.source.y; })
          .attr("x2", function (d) { return d.target.x; })
          .attr("y2", function (d) { return d.target.y; });

        node
          .attr("cx", function (d) { return d.x; })
          .attr("cy", function (d) { return d.y; });
      }
    });

    function dragstarted(d) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    // function dragended(d) {
    //   if (!d3.event.active) simulation.alphaTarget(0);
    //   d.fx = null;
    //   d.fy = null;
    // }

    function keydown() {
      brushMode = d3.event.metaKey;
      const cleanNodes = d3.event.keyCode === 68;
      if (brushMode) zoomLayer.attr("pointer-events", "none");
      if (cleanNodes) cleanSelected();
    }

    function keyup() {
      brushMode = d3.event.metaKey;
      if (!brushMode) zoomLayer.attr("pointer-events", "all");
    }

    function zoomed() {
      g.attr("transform", d3.event.transform);
    }

    function cleanSelected() {
      node.classed("picked", false);
      node.each(function (d) { d.picked = d.previouslyPicked = false; })
    }

  </script> -->
</body>

</html>